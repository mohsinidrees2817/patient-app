"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"10a894005e47\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvbW9oc2luaWRyZWVzL0Rlc2t0b3AvcGF0aWVudC1hcHAvc3RhdGljL3NyYy9hcHAvZ2xvYmFscy5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIxMGE4OTQwMDVlNDdcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/context/Globalcontext.jsx":
/*!***************************************!*\
  !*** ./src/context/Globalcontext.jsx ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MainProvider: () => (/* binding */ MainProvider),\n/* harmony export */   useMainProvider: () => (/* binding */ useMainProvider)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! papaparse */ \"(app-pages-browser)/./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\");\n/* __next_internal_client_entry_do_not_use__ MainProvider,useMainProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst MainContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nconst MainProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [tableData, setTableData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [proccesingState, setProccesingState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [files, setFiles] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const API_BASE = \"http://localhost:8000\" || 0;\n    const allowedFileTypes = [\n        \"text/csv\",\n        \"application/vnd.ms-excel\",\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n    ];\n    const parseFile = (file)=>{\n        return new Promise((resolve)=>{\n            const reader = new FileReader();\n            reader.onload = (param)=>{\n                let { target } = param;\n                let dataWithStatus = [];\n                if (file.type === \"text/csv\") {\n                    papaparse__WEBPACK_IMPORTED_MODULE_2___default().parse(target.result, {\n                        header: true,\n                        skipEmptyLines: true,\n                        complete: (result)=>{\n                            dataWithStatus = result.data.map((row)=>({\n                                    ...row,\n                                    status: \"Pending\",\n                                    summary: \"\",\n                                    clas\n                                }));\n                            resolve(dataWithStatus);\n                        }\n                    });\n                } else if (file.type === \"application/vnd.ms-excel\" || file.type === \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") {\n                    const workbook = xlsx__WEBPACK_IMPORTED_MODULE_3__.read(target.result, {\n                        type: \"binary\"\n                    });\n                    const sheetName = workbook.SheetNames[0];\n                    const worksheet = workbook.Sheets[sheetName];\n                    const jsonData = xlsx__WEBPACK_IMPORTED_MODULE_3__.utils.sheet_to_json(worksheet, {\n                        header: 1\n                    });\n                    const headers = jsonData[0];\n                    const rows = jsonData.slice(1);\n                    dataWithStatus = rows.map((row)=>{\n                        const rowData = {};\n                        headers.forEach((header, index)=>{\n                            rowData[header] = row[index];\n                        });\n                        return {\n                            ...rowData,\n                            status: \"Pending\",\n                            summary: \"\"\n                        };\n                    });\n                    resolve(dataWithStatus);\n                } else {\n                    console.error(\"Unsupported file type:\", file.type);\n                    resolve([]);\n                }\n            };\n            if (file.type === \"text/csv\") {\n                reader.readAsText(file);\n            } else {\n                reader.readAsBinaryString(file);\n            }\n        });\n    };\n    const handleFileUpload = async (files)=>{\n        const nonDuplicateFiles = files.filter((file)=>{\n            const isDuplicate = data.some((item)=>item.file.name === file.name && item.file.size === file.size);\n            if (isDuplicate) {\n                console.warn(\"Skipping duplicate file: \".concat(file.name));\n                return false;\n            }\n            return true;\n        });\n        if (nonDuplicateFiles.length === 0) {\n            console.warn(\"No new files to upload (all files are duplicates).\");\n            return;\n        }\n        const filesWithData = await Promise.all(nonDuplicateFiles.map(async (file)=>{\n            const tableData = await parseFile(file);\n            return {\n                file,\n                status: \"Pending\",\n                summary: \"\",\n                classification: \"\",\n                tableData\n            };\n        }));\n        setData((prevData)=>[\n                ...prevData,\n                ...filesWithData\n            ]);\n        setSelectedFile(nonDuplicateFiles[0]);\n        setTableData(filesWithData[0].tableData);\n    };\n    const handleFileChange = (event)=>{\n        const selectedFiles = Array.from(event.target.files);\n        const filteredFiles = selectedFiles.filter((file)=>allowedFileTypes.includes(file.type));\n        if (filteredFiles.length > 0) {\n            setFiles((prevFiles)=>[\n                    ...prevFiles,\n                    ...filteredFiles\n                ]);\n            handleFileUpload(filteredFiles);\n        }\n    };\n    const handleFileSelect = (file)=>{\n        setSelectedFile(file);\n        const existingFileData = data.find((item)=>item.file.name === file.name);\n        if (existingFileData) {\n            setTableData(existingFileData.tableData);\n        }\n    };\n    const handleDrop = (event)=>{\n        event.preventDefault();\n        const droppedFiles = Array.from(event.dataTransfer.files);\n        const filteredFiles = droppedFiles.filter((file)=>allowedFileTypes.includes(file.type));\n        if (filteredFiles.length > 0) {\n            setFiles((prevFiles)=>[\n                    ...prevFiles,\n                    ...filteredFiles\n                ]);\n            setData((prevData)=>[\n                    ...prevData,\n                    ...filteredFiles\n                ]);\n        }\n    };\n    const handleRemoveFile = (file)=>{\n        setData((prevData)=>prevData.filter((item)=>item.file.name !== file.name));\n        setFiles((prevFiles)=>prevFiles.filter((prevFile)=>prevFile.name !== file.name));\n        if ((selectedFile === null || selectedFile === void 0 ? void 0 : selectedFile.name) === file.name) {\n            const remainingFiles = data.filter((item)=>item.file.name !== file.name);\n            if (remainingFiles.length > 0) {\n                setSelectedFile(remainingFiles[0].file);\n                setTableData(remainingFiles[0].tableData);\n            } else {\n                setSelectedFile(null);\n                setTableData([]);\n            }\n        }\n        if (fileInputRef.current) {\n            fileInputRef.current.value = \"\";\n        }\n    };\n    const startStreaming = async (file)=>{\n        const fileData = data.find((item)=>item.file.name === file.name);\n        if (!fileData || fileData.status !== \"Pending\") return;\n        setProccesingState(true);\n        setData((prevData)=>prevData.map((item)=>item.file.name === file.name ? {\n                    ...item,\n                    status: \"In Progress\"\n                } : item));\n        for(let i = 0; i < fileData.tableData.length; i++){\n            const row = fileData.tableData[i];\n            if (row.status === \"Done\") {\n                continue;\n            }\n            updateRowStatus(i, \"In Progress\");\n            const summary = await streamSummary(row, i, file);\n            if (summary) {\n                updateRowStatus(i, \"Done\");\n                updateRowSummary(i, summary);\n                setData((prevData)=>prevData.map((item)=>item.file.name === file.name ? {\n                            ...item,\n                            tableData: item.tableData.map((r, idx)=>idx === i ? {\n                                    ...r,\n                                    status: \"Done\",\n                                    summary\n                                } : r)\n                        } : item));\n            }\n        }\n        setData((prevData)=>prevData.map((item)=>item.file.name === file.name ? {\n                    ...item,\n                    status: \"Done\"\n                } : item));\n        setProccesingState(false);\n    };\n    const streamSummary = async (row, rowIndex, file)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE, \"/generate-summary\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(row)\n            });\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const reader = response.body.getReader();\n            const decoder = new TextDecoder();\n            let summary = \"\";\n            let classification = \"\";\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                const chunk = decoder.decode(value, {\n                    stream: true\n                });\n                if (chunk.includes(\"summary:\")) {\n                    const summaryChunk = chunk.replace(\"summary:\", \"\").trim();\n                    summary += summaryChunk + \" \";\n                    updateRowSummary(rowIndex, summary);\n                } else if (chunk.includes(\"classification:\")) {\n                    const classificationChunk = chunk.replace(\"classification:\", \"\").trim();\n                    classification += classificationChunk + \" \";\n                    updateRowClassification(rowIndex, classification);\n                }\n            }\n            updateRowStatus(rowIndex, \"Done\");\n        } catch (error) {\n            console.error(\"Error streaming summary:\", error);\n            updateRowStatus(rowIndex, \"Error!\");\n            updateRowSummary(rowIndex, \"\");\n            updateRowClassification(rowIndex, \"\");\n            setData((prevData)=>prevData.map((item)=>item.file.name === file.name ? {\n                        ...item,\n                        tableData: item.tableData.map((r, idx)=>idx === rowIndex ? {\n                                ...r,\n                                status: \"Error!\",\n                                summary: \"\",\n                                classification: \"\"\n                            } : r)\n                    } : item));\n        }\n    };\n    const updateRowClassification = (rowIndex, classification)=>{\n        setTableData((prev)=>prev.map((row, i)=>i === rowIndex ? {\n                    ...row,\n                    classification\n                } : row));\n        setData((prevData)=>prevData.map((item)=>item.file.name === selectedFile.name ? {\n                    ...item,\n                    tableData: item.tableData.map((row, idx)=>idx === rowIndex ? {\n                            ...row,\n                            classification\n                        } : row)\n                } : item));\n    };\n    const updateRowSummary = (rowIndex, summary)=>{\n        setTableData((prev)=>prev.map((row, i)=>i === rowIndex ? {\n                    ...row,\n                    summary\n                } : row));\n        setData((prevData)=>prevData.map((item)=>item.file.name === selectedFile.name ? {\n                    ...item,\n                    tableData: item.tableData.map((row, idx)=>idx === rowIndex ? {\n                            ...row,\n                            summary\n                        } : row)\n                } : item));\n    };\n    const updateRowStatus = (index, status)=>{\n        setTableData((prev)=>prev.map((row, i)=>i === index ? {\n                    ...row,\n                    status\n                } : row));\n        setData((prevData)=>prevData.map((item)=>item.file.name === selectedFile.name ? {\n                    ...item,\n                    tableData: item.tableData.map((row, idx)=>idx === index ? {\n                            ...row,\n                            status\n                        } : row)\n                } : item));\n    };\n    const updateSummaryInGlobalState = (file, rowIndex, newSummary)=>{\n        setData((prevData)=>prevData.map((item)=>item.file.name === file.name ? {\n                    ...item,\n                    status: \"Pending\",\n                    tableData: item.tableData.map((row, idx)=>idx === rowIndex ? {\n                            ...row,\n                            summary: newSummary,\n                            classification: \"\",\n                            status: \"Pending\"\n                        } : row)\n                } : item));\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MainContext.Provider, {\n        value: {\n            data,\n            setData,\n            selectedFile,\n            setSelectedFile,\n            tableData,\n            setTableData,\n            handleFileUpload,\n            startStreaming,\n            updateRowSummary,\n            updateRowStatus,\n            updateSummaryInGlobalState,\n            proccesingState,\n            setProccesingState,\n            files,\n            setFiles,\n            handleFileChange,\n            handleFileSelect,\n            handleDrop,\n            handleRemoveFile,\n            fileInputRef\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/mohsinidrees/Desktop/patient-app/static/src/context/Globalcontext.jsx\",\n        lineNumber: 379,\n        columnNumber: 5\n    }, undefined);\n};\n_s(MainProvider, \"ZuR22oAp/F9EYXm+6joOyMZ4/g8=\");\n_c = MainProvider;\nconst useMainProvider = ()=>{\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MainContext);\n};\n_s1(useMainProvider, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"MainProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L0dsb2JhbGNvbnRleHQuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFDMkU7QUFDOUM7QUFDQTtBQUU3QixNQUFNTyw0QkFBY04sb0RBQWFBO0FBRTFCLE1BQU1PLGVBQWU7UUFBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQ3ZDLE1BQU0sQ0FBQ0MsTUFBTUMsUUFBUSxHQUFHUiwrQ0FBUUEsQ0FBQyxFQUFFO0lBQ25DLE1BQU0sQ0FBQ1MsY0FBY0MsZ0JBQWdCLEdBQUdWLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ1csV0FBV0MsYUFBYSxHQUFHWiwrQ0FBUUEsQ0FBQyxFQUFFO0lBQzdDLE1BQU0sQ0FBQ2EsaUJBQWlCQyxtQkFBbUIsR0FBR2QsK0NBQVFBLENBQUM7SUFDdkQsTUFBTSxDQUFDZSxPQUFPQyxTQUFTLEdBQUdoQiwrQ0FBUUEsQ0FBQyxFQUFFO0lBQ3JDLE1BQU1pQixlQUFlaEIsNkNBQU1BLENBQUM7SUFFNUIsTUFBTWlCLFdBQVdDLHVCQUFnQyxJQUFJLENBQUU7SUFFdkQsTUFBTUcsbUJBQW1CO1FBQ3ZCO1FBQ0E7UUFDQTtLQUNEO0lBRUQsTUFBTUMsWUFBWSxDQUFDQztRQUNqQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0M7WUFDbEIsTUFBTUMsU0FBUyxJQUFJQztZQUNuQkQsT0FBT0UsTUFBTSxHQUFHO29CQUFDLEVBQUVDLE1BQU0sRUFBRTtnQkFDekIsSUFBSUMsaUJBQWlCLEVBQUU7Z0JBRXZCLElBQUlQLEtBQUtRLElBQUksS0FBSyxZQUFZO29CQUM1QjlCLHNEQUFVLENBQUM0QixPQUFPSSxNQUFNLEVBQUU7d0JBQ3hCQyxRQUFRO3dCQUNSQyxnQkFBZ0I7d0JBQ2hCQyxVQUFVLENBQUNIOzRCQUNUSCxpQkFBaUJHLE9BQU8zQixJQUFJLENBQUMrQixHQUFHLENBQUMsQ0FBQ0MsTUFBUztvQ0FDekMsR0FBR0EsR0FBRztvQ0FDTkMsUUFBUTtvQ0FDUkMsU0FBUztv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QVMsQ0FBQzJCLEdBQUcsQ0FBQyxDQUFDQyxLQUFLZ0UsTUFDbENBLFFBQVE5QyxRQUFROzRCQUFFLEdBQUdsQixHQUFHOzRCQUFFQzt3QkFBTyxJQUFJRDtnQkFFekMsSUFDQTRCO0lBR1Y7SUFFQSxNQUFNMkQsNkJBQTZCLENBQUN0RyxNQUFNZ0YsVUFBVXVCO1FBQ2xEdkgsUUFBUSxDQUFDbUUsV0FDUEEsU0FBU3JDLEdBQUcsQ0FBQyxDQUFDNkIsT0FDWkEsS0FBSzNDLElBQUksQ0FBQzRDLElBQUksS0FBSzVDLEtBQUs0QyxJQUFJLEdBQ3hCO29CQUNFLEdBQUdELElBQUk7b0JBQ1AzQixRQUFRO29CQUNSN0IsV0FBV3dELEtBQUt4RCxTQUFTLENBQUMyQixHQUFHLENBQUMsQ0FBQ0MsS0FBS2dFLE1BQ2xDQSxRQUFRQyxXQUNKOzRCQUNFLEdBQUdqRSxHQUFHOzRCQUNORSxTQUFTc0Y7NEJBQ1RyRCxnQkFBZ0I7NEJBQ2hCbEMsUUFBUTt3QkFDVixJQUNBRDtnQkFFUixJQUNBNEI7SUFHVjtJQUVBLHFCQUNFLDhEQUFDL0QsWUFBWTRILFFBQVE7UUFDbkJqQyxPQUFPO1lBQ0x4RjtZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBa0Q7WUFDQWtDO1lBQ0FLO1lBQ0FGO1lBQ0EyQjtZQUNBakg7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQTREO1lBQ0FRO1lBQ0FHO1lBQ0FJO1lBQ0ExRTtRQUNGO2tCQUVDWDs7Ozs7O0FBR1AsRUFBRTtHQTlZV0Q7S0FBQUE7QUErWU4sTUFBTTRILGtCQUFrQjs7SUFBTWxJLE9BQUFBLGlEQUFVQSxDQUFDSztBQUFXLEVBQUU7SUFBaEQ2SCIsInNvdXJjZXMiOlsiL1VzZXJzL21vaHNpbmlkcmVlcy9EZXNrdG9wL3BhdGllbnQtYXBwL3N0YXRpYy9zcmMvY29udGV4dC9HbG9iYWxjb250ZXh0LmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUGFwYSBmcm9tIFwicGFwYXBhcnNlXCI7XG5pbXBvcnQgKiBhcyBYTFNYIGZyb20gXCJ4bHN4XCI7XG5cbmNvbnN0IE1haW5Db250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xuXG5leHBvcnQgY29uc3QgTWFpblByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbZGF0YSwgc2V0RGF0YV0gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW3RhYmxlRGF0YSwgc2V0VGFibGVEYXRhXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3Byb2NjZXNpbmdTdGF0ZSwgc2V0UHJvY2Nlc2luZ1N0YXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2ZpbGVzLCBzZXRGaWxlc10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IGZpbGVJbnB1dFJlZiA9IHVzZVJlZihudWxsKTtcblxuICBjb25zdCBBUElfQkFTRSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9CQVNFIHx8IFwiXCI7XG5cbiAgY29uc3QgYWxsb3dlZEZpbGVUeXBlcyA9IFtcbiAgICBcInRleHQvY3N2XCIsXG4gICAgXCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWxcIixcbiAgICBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0XCIsXG4gIF07XG5cbiAgY29uc3QgcGFyc2VGaWxlID0gKGZpbGUpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICByZWFkZXIub25sb2FkID0gKHsgdGFyZ2V0IH0pID0+IHtcbiAgICAgICAgbGV0IGRhdGFXaXRoU3RhdHVzID0gW107XG5cbiAgICAgICAgaWYgKGZpbGUudHlwZSA9PT0gXCJ0ZXh0L2NzdlwiKSB7XG4gICAgICAgICAgUGFwYS5wYXJzZSh0YXJnZXQucmVzdWx0LCB7XG4gICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICBza2lwRW1wdHlMaW5lczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGRhdGFXaXRoU3RhdHVzID0gcmVzdWx0LmRhdGEubWFwKChyb3cpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4ucm93LFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJQZW5kaW5nXCIsXG4gICAgICAgICAgICAgICAgc3VtbWFyeTogXCJcIixcbiAgICAgICAgICAgICAgICBjbGFzXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhV2l0aFN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGZpbGUudHlwZSA9PT0gXCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWxcIiB8fFxuICAgICAgICAgIGZpbGUudHlwZSA9PT1cbiAgICAgICAgICAgIFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXRcIlxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCB3b3JrYm9vayA9IFhMU1gucmVhZCh0YXJnZXQucmVzdWx0LCB7IHR5cGU6IFwiYmluYXJ5XCIgfSk7XG4gICAgICAgICAgY29uc3Qgc2hlZXROYW1lID0gd29ya2Jvb2suU2hlZXROYW1lc1swXTtcbiAgICAgICAgICBjb25zdCB3b3Jrc2hlZXQgPSB3b3JrYm9vay5TaGVldHNbc2hlZXROYW1lXTtcbiAgICAgICAgICBjb25zdCBqc29uRGF0YSA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbih3b3Jrc2hlZXQsIHsgaGVhZGVyOiAxIH0pO1xuXG4gICAgICAgICAgY29uc3QgaGVhZGVycyA9IGpzb25EYXRhWzBdO1xuICAgICAgICAgIGNvbnN0IHJvd3MgPSBqc29uRGF0YS5zbGljZSgxKTtcblxuICAgICAgICAgIGRhdGFXaXRoU3RhdHVzID0gcm93cy5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93RGF0YSA9IHt9O1xuICAgICAgICAgICAgaGVhZGVycy5mb3JFYWNoKChoZWFkZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIHJvd0RhdGFbaGVhZGVyXSA9IHJvd1tpbmRleF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnJvd0RhdGEsXG4gICAgICAgICAgICAgIHN0YXR1czogXCJQZW5kaW5nXCIsXG4gICAgICAgICAgICAgIHN1bW1hcnk6IFwiXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVzb2x2ZShkYXRhV2l0aFN0YXR1cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlVuc3VwcG9ydGVkIGZpbGUgdHlwZTpcIiwgZmlsZS50eXBlKTtcbiAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGZpbGUudHlwZSA9PT0gXCJ0ZXh0L2NzdlwiKSB7XG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZyhmaWxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVGaWxlVXBsb2FkID0gYXN5bmMgKGZpbGVzKSA9PiB7XG4gICAgY29uc3Qgbm9uRHVwbGljYXRlRmlsZXMgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IGlzRHVwbGljYXRlID0gZGF0YS5zb21lKFxuICAgICAgICAoaXRlbSkgPT4gaXRlbS5maWxlLm5hbWUgPT09IGZpbGUubmFtZSAmJiBpdGVtLmZpbGUuc2l6ZSA9PT0gZmlsZS5zaXplXG4gICAgICApO1xuICAgICAgaWYgKGlzRHVwbGljYXRlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgU2tpcHBpbmcgZHVwbGljYXRlIGZpbGU6ICR7ZmlsZS5uYW1lfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmIChub25EdXBsaWNhdGVGaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIG5ldyBmaWxlcyB0byB1cGxvYWQgKGFsbCBmaWxlcyBhcmUgZHVwbGljYXRlcykuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbGVzV2l0aERhdGEgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG5vbkR1cGxpY2F0ZUZpbGVzLm1hcChhc3luYyAoZmlsZSkgPT4ge1xuICAgICAgICBjb25zdCB0YWJsZURhdGEgPSBhd2FpdCBwYXJzZUZpbGUoZmlsZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZmlsZSxcbiAgICAgICAgICBzdGF0dXM6IFwiUGVuZGluZ1wiLFxuICAgICAgICAgIHN1bW1hcnk6IFwiXCIsXG4gICAgICAgICAgY2xhc3NpZmljYXRpb246IFwiXCIsXG4gICAgICAgICAgdGFibGVEYXRhLFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgc2V0RGF0YSgocHJldkRhdGEpID0+IFsuLi5wcmV2RGF0YSwgLi4uZmlsZXNXaXRoRGF0YV0pO1xuXG4gICAgc2V0U2VsZWN0ZWRGaWxlKG5vbkR1cGxpY2F0ZUZpbGVzWzBdKTtcblxuICAgIHNldFRhYmxlRGF0YShmaWxlc1dpdGhEYXRhWzBdLnRhYmxlRGF0YSk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkRmlsZXMgPSBBcnJheS5mcm9tKGV2ZW50LnRhcmdldC5maWxlcyk7XG4gICAgY29uc3QgZmlsdGVyZWRGaWxlcyA9IHNlbGVjdGVkRmlsZXMuZmlsdGVyKChmaWxlKSA9PlxuICAgICAgYWxsb3dlZEZpbGVUeXBlcy5pbmNsdWRlcyhmaWxlLnR5cGUpXG4gICAgKTtcblxuICAgIGlmIChmaWx0ZXJlZEZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNldEZpbGVzKChwcmV2RmlsZXMpID0+IFsuLi5wcmV2RmlsZXMsIC4uLmZpbHRlcmVkRmlsZXNdKTtcbiAgICAgIGhhbmRsZUZpbGVVcGxvYWQoZmlsdGVyZWRGaWxlcyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUZpbGVTZWxlY3QgPSAoZmlsZSkgPT4ge1xuICAgIHNldFNlbGVjdGVkRmlsZShmaWxlKTtcblxuICAgIGNvbnN0IGV4aXN0aW5nRmlsZURhdGEgPSBkYXRhLmZpbmQoKGl0ZW0pID0+IGl0ZW0uZmlsZS5uYW1lID09PSBmaWxlLm5hbWUpO1xuXG4gICAgaWYgKGV4aXN0aW5nRmlsZURhdGEpIHtcbiAgICAgIHNldFRhYmxlRGF0YShleGlzdGluZ0ZpbGVEYXRhLnRhYmxlRGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZURyb3AgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGRyb3BwZWRGaWxlcyA9IEFycmF5LmZyb20oZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKTtcbiAgICBjb25zdCBmaWx0ZXJlZEZpbGVzID0gZHJvcHBlZEZpbGVzLmZpbHRlcigoZmlsZSkgPT5cbiAgICAgIGFsbG93ZWRGaWxlVHlwZXMuaW5jbHVkZXMoZmlsZS50eXBlKVxuICAgICk7XG5cbiAgICBpZiAoZmlsdGVyZWRGaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBzZXRGaWxlcygocHJldkZpbGVzKSA9PiBbLi4ucHJldkZpbGVzLCAuLi5maWx0ZXJlZEZpbGVzXSk7XG4gICAgICBzZXREYXRhKChwcmV2RGF0YSkgPT4gWy4uLnByZXZEYXRhLCAuLi5maWx0ZXJlZEZpbGVzXSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVJlbW92ZUZpbGUgPSAoZmlsZSkgPT4ge1xuICAgIHNldERhdGEoKHByZXZEYXRhKSA9PlxuICAgICAgcHJldkRhdGEuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmZpbGUubmFtZSAhPT0gZmlsZS5uYW1lKVxuICAgICk7XG5cbiAgICBzZXRGaWxlcygocHJldkZpbGVzKSA9PlxuICAgICAgcHJldkZpbGVzLmZpbHRlcigocHJldkZpbGUpID0+IHByZXZGaWxlLm5hbWUgIT09IGZpbGUubmFtZSlcbiAgICApO1xuXG4gICAgaWYgKHNlbGVjdGVkRmlsZT8ubmFtZSA9PT0gZmlsZS5uYW1lKSB7XG4gICAgICBjb25zdCByZW1haW5pbmdGaWxlcyA9IGRhdGEuZmlsdGVyKFxuICAgICAgICAoaXRlbSkgPT4gaXRlbS5maWxlLm5hbWUgIT09IGZpbGUubmFtZVxuICAgICAgKTtcblxuICAgICAgaWYgKHJlbWFpbmluZ0ZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2V0U2VsZWN0ZWRGaWxlKHJlbWFpbmluZ0ZpbGVzWzBdLmZpbGUpO1xuICAgICAgICBzZXRUYWJsZURhdGEocmVtYWluaW5nRmlsZXNbMF0udGFibGVEYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkRmlsZShudWxsKTtcbiAgICAgICAgc2V0VGFibGVEYXRhKFtdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbGVJbnB1dFJlZi5jdXJyZW50KSB7XG4gICAgICBmaWxlSW5wdXRSZWYuY3VycmVudC52YWx1ZSA9IFwiXCI7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHN0YXJ0U3RyZWFtaW5nID0gYXN5bmMgKGZpbGUpID0+IHtcbiAgICBjb25zdCBmaWxlRGF0YSA9IGRhdGEuZmluZCgoaXRlbSkgPT4gaXRlbS5maWxlLm5hbWUgPT09IGZpbGUubmFtZSk7XG4gICAgaWYgKCFmaWxlRGF0YSB8fCBmaWxlRGF0YS5zdGF0dXMgIT09IFwiUGVuZGluZ1wiKSByZXR1cm47XG4gICAgc2V0UHJvY2Nlc2luZ1N0YXRlKHRydWUpO1xuXG4gICAgc2V0RGF0YSgocHJldkRhdGEpID0+XG4gICAgICBwcmV2RGF0YS5tYXAoKGl0ZW0pID0+XG4gICAgICAgIGl0ZW0uZmlsZS5uYW1lID09PSBmaWxlLm5hbWUgPyB7IC4uLml0ZW0sIHN0YXR1czogXCJJbiBQcm9ncmVzc1wiIH0gOiBpdGVtXG4gICAgICApXG4gICAgKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZURhdGEudGFibGVEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByb3cgPSBmaWxlRGF0YS50YWJsZURhdGFbaV07XG5cbiAgICAgIGlmIChyb3cuc3RhdHVzID09PSBcIkRvbmVcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlUm93U3RhdHVzKGksIFwiSW4gUHJvZ3Jlc3NcIik7XG5cbiAgICAgIGNvbnN0IHN1bW1hcnkgPSBhd2FpdCBzdHJlYW1TdW1tYXJ5KHJvdywgaSwgZmlsZSk7XG5cbiAgICAgIGlmIChzdW1tYXJ5KSB7XG4gICAgICAgIHVwZGF0ZVJvd1N0YXR1cyhpLCBcIkRvbmVcIik7XG4gICAgICAgIHVwZGF0ZVJvd1N1bW1hcnkoaSwgc3VtbWFyeSk7XG5cbiAgICAgICAgc2V0RGF0YSgocHJldkRhdGEpID0+XG4gICAgICAgICAgcHJldkRhdGEubWFwKChpdGVtKSA9PlxuICAgICAgICAgICAgaXRlbS5maWxlLm5hbWUgPT09IGZpbGUubmFtZVxuICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgICAgICB0YWJsZURhdGE6IGl0ZW0udGFibGVEYXRhLm1hcCgociwgaWR4KSA9PlxuICAgICAgICAgICAgICAgICAgICBpZHggPT09IGkgPyB7IC4uLnIsIHN0YXR1czogXCJEb25lXCIsIHN1bW1hcnkgfSA6IHJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6IGl0ZW1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0RGF0YSgocHJldkRhdGEpID0+XG4gICAgICBwcmV2RGF0YS5tYXAoKGl0ZW0pID0+XG4gICAgICAgIGl0ZW0uZmlsZS5uYW1lID09PSBmaWxlLm5hbWUgPyB7IC4uLml0ZW0sIHN0YXR1czogXCJEb25lXCIgfSA6IGl0ZW1cbiAgICAgIClcbiAgICApO1xuXG4gICAgc2V0UHJvY2Nlc2luZ1N0YXRlKGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBzdHJlYW1TdW1tYXJ5ID0gYXN5bmMgKHJvdywgcm93SW5kZXgsIGZpbGUpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRX0vZ2VuZXJhdGUtc3VtbWFyeWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyb3cpLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgbGV0IHN1bW1hcnkgPSBcIlwiO1xuICAgICAgbGV0IGNsYXNzaWZpY2F0aW9uID0gXCJcIjtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuXG4gICAgICAgIGNvbnN0IGNodW5rID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuXG4gICAgICAgIGlmIChjaHVuay5pbmNsdWRlcyhcInN1bW1hcnk6XCIpKSB7XG4gICAgICAgICAgY29uc3Qgc3VtbWFyeUNodW5rID0gY2h1bmsucmVwbGFjZShcInN1bW1hcnk6XCIsIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICBzdW1tYXJ5ICs9IHN1bW1hcnlDaHVuayArIFwiIFwiO1xuICAgICAgICAgIHVwZGF0ZVJvd1N1bW1hcnkocm93SW5kZXgsIHN1bW1hcnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNodW5rLmluY2x1ZGVzKFwiY2xhc3NpZmljYXRpb246XCIpKSB7XG4gICAgICAgICAgY29uc3QgY2xhc3NpZmljYXRpb25DaHVuayA9IGNodW5rXG4gICAgICAgICAgICAucmVwbGFjZShcImNsYXNzaWZpY2F0aW9uOlwiLCBcIlwiKVxuICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgICBjbGFzc2lmaWNhdGlvbiArPSBjbGFzc2lmaWNhdGlvbkNodW5rICsgXCIgXCI7XG4gICAgICAgICAgdXBkYXRlUm93Q2xhc3NpZmljYXRpb24ocm93SW5kZXgsIGNsYXNzaWZpY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGRhdGVSb3dTdGF0dXMocm93SW5kZXgsIFwiRG9uZVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHN0cmVhbWluZyBzdW1tYXJ5OlwiLCBlcnJvcik7XG4gICAgICB1cGRhdGVSb3dTdGF0dXMocm93SW5kZXgsIFwiRXJyb3IhXCIpO1xuICAgICAgdXBkYXRlUm93U3VtbWFyeShyb3dJbmRleCwgXCJcIik7XG4gICAgICB1cGRhdGVSb3dDbGFzc2lmaWNhdGlvbihyb3dJbmRleCwgXCJcIik7XG5cbiAgICAgIHNldERhdGEoKHByZXZEYXRhKSA9PlxuICAgICAgICBwcmV2RGF0YS5tYXAoKGl0ZW0pID0+XG4gICAgICAgICAgaXRlbS5maWxlLm5hbWUgPT09IGZpbGUubmFtZVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgICAgICB0YWJsZURhdGE6IGl0ZW0udGFibGVEYXRhLm1hcCgociwgaWR4KSA9PlxuICAgICAgICAgICAgICAgICAgaWR4ID09PSByb3dJbmRleFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiRXJyb3IhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NpZmljYXRpb246IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGl0ZW1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlUm93Q2xhc3NpZmljYXRpb24gPSAocm93SW5kZXgsIGNsYXNzaWZpY2F0aW9uKSA9PiB7XG4gICAgc2V0VGFibGVEYXRhKChwcmV2KSA9PlxuICAgICAgcHJldi5tYXAoKHJvdywgaSkgPT4gKGkgPT09IHJvd0luZGV4ID8geyAuLi5yb3csIGNsYXNzaWZpY2F0aW9uIH0gOiByb3cpKVxuICAgICk7XG5cbiAgICBzZXREYXRhKChwcmV2RGF0YSkgPT5cbiAgICAgIHByZXZEYXRhLm1hcCgoaXRlbSkgPT5cbiAgICAgICAgaXRlbS5maWxlLm5hbWUgPT09IHNlbGVjdGVkRmlsZS5uYW1lXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgIHRhYmxlRGF0YTogaXRlbS50YWJsZURhdGEubWFwKChyb3csIGlkeCkgPT5cbiAgICAgICAgICAgICAgICBpZHggPT09IHJvd0luZGV4ID8geyAuLi5yb3csIGNsYXNzaWZpY2F0aW9uIH0gOiByb3dcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IGl0ZW1cbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZVJvd1N1bW1hcnkgPSAocm93SW5kZXgsIHN1bW1hcnkpID0+IHtcbiAgICBzZXRUYWJsZURhdGEoKHByZXYpID0+XG4gICAgICBwcmV2Lm1hcCgocm93LCBpKSA9PiAoaSA9PT0gcm93SW5kZXggPyB7IC4uLnJvdywgc3VtbWFyeSB9IDogcm93KSlcbiAgICApO1xuXG4gICAgc2V0RGF0YSgocHJldkRhdGEpID0+XG4gICAgICBwcmV2RGF0YS5tYXAoKGl0ZW0pID0+XG4gICAgICAgIGl0ZW0uZmlsZS5uYW1lID09PSBzZWxlY3RlZEZpbGUubmFtZVxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICB0YWJsZURhdGE6IGl0ZW0udGFibGVEYXRhLm1hcCgocm93LCBpZHgpID0+XG4gICAgICAgICAgICAgICAgaWR4ID09PSByb3dJbmRleCA/IHsgLi4ucm93LCBzdW1tYXJ5IH0gOiByb3dcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IGl0ZW1cbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZVJvd1N0YXR1cyA9IChpbmRleCwgc3RhdHVzKSA9PiB7XG4gICAgc2V0VGFibGVEYXRhKChwcmV2KSA9PlxuICAgICAgcHJldi5tYXAoKHJvdywgaSkgPT4gKGkgPT09IGluZGV4ID8geyAuLi5yb3csIHN0YXR1cyB9IDogcm93KSlcbiAgICApO1xuXG4gICAgc2V0RGF0YSgocHJldkRhdGEpID0+XG4gICAgICBwcmV2RGF0YS5tYXAoKGl0ZW0pID0+XG4gICAgICAgIGl0ZW0uZmlsZS5uYW1lID09PSBzZWxlY3RlZEZpbGUubmFtZVxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICB0YWJsZURhdGE6IGl0ZW0udGFibGVEYXRhLm1hcCgocm93LCBpZHgpID0+XG4gICAgICAgICAgICAgICAgaWR4ID09PSBpbmRleCA/IHsgLi4ucm93LCBzdGF0dXMgfSA6IHJvd1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogaXRlbVxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlU3VtbWFyeUluR2xvYmFsU3RhdGUgPSAoZmlsZSwgcm93SW5kZXgsIG5ld1N1bW1hcnkpID0+IHtcbiAgICBzZXREYXRhKChwcmV2RGF0YSkgPT5cbiAgICAgIHByZXZEYXRhLm1hcCgoaXRlbSkgPT5cbiAgICAgICAgaXRlbS5maWxlLm5hbWUgPT09IGZpbGUubmFtZVxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICBzdGF0dXM6IFwiUGVuZGluZ1wiLFxuICAgICAgICAgICAgICB0YWJsZURhdGE6IGl0ZW0udGFibGVEYXRhLm1hcCgocm93LCBpZHgpID0+XG4gICAgICAgICAgICAgICAgaWR4ID09PSByb3dJbmRleFxuICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4ucm93LFxuICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IG5ld1N1bW1hcnksXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NpZmljYXRpb246IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIlBlbmRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgOiByb3dcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IGl0ZW1cbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPE1haW5Db250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICBkYXRhLFxuICAgICAgICBzZXREYXRhLFxuICAgICAgICBzZWxlY3RlZEZpbGUsXG4gICAgICAgIHNldFNlbGVjdGVkRmlsZSxcbiAgICAgICAgdGFibGVEYXRhLFxuICAgICAgICBzZXRUYWJsZURhdGEsXG4gICAgICAgIGhhbmRsZUZpbGVVcGxvYWQsXG4gICAgICAgIHN0YXJ0U3RyZWFtaW5nLFxuICAgICAgICB1cGRhdGVSb3dTdW1tYXJ5LFxuICAgICAgICB1cGRhdGVSb3dTdGF0dXMsXG4gICAgICAgIHVwZGF0ZVN1bW1hcnlJbkdsb2JhbFN0YXRlLFxuICAgICAgICBwcm9jY2VzaW5nU3RhdGUsXG4gICAgICAgIHNldFByb2NjZXNpbmdTdGF0ZSxcbiAgICAgICAgZmlsZXMsXG4gICAgICAgIHNldEZpbGVzLFxuICAgICAgICBoYW5kbGVGaWxlQ2hhbmdlLFxuICAgICAgICBoYW5kbGVGaWxlU2VsZWN0LFxuICAgICAgICBoYW5kbGVEcm9wLFxuICAgICAgICBoYW5kbGVSZW1vdmVGaWxlLFxuICAgICAgICBmaWxlSW5wdXRSZWYsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L01haW5Db250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcbmV4cG9ydCBjb25zdCB1c2VNYWluUHJvdmlkZXIgPSAoKSA9PiB1c2VDb250ZXh0KE1haW5Db250ZXh0KTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJQYXBhIiwiWExTWCIsIk1haW5Db250ZXh0IiwiTWFpblByb3ZpZGVyIiwiY2hpbGRyZW4iLCJkYXRhIiwic2V0RGF0YSIsInNlbGVjdGVkRmlsZSIsInNldFNlbGVjdGVkRmlsZSIsInRhYmxlRGF0YSIsInNldFRhYmxlRGF0YSIsInByb2NjZXNpbmdTdGF0ZSIsInNldFByb2NjZXNpbmdTdGF0ZSIsImZpbGVzIiwic2V0RmlsZXMiLCJmaWxlSW5wdXRSZWYiLCJBUElfQkFTRSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfQkFTRSIsImFsbG93ZWRGaWxlVHlwZXMiLCJwYXJzZUZpbGUiLCJmaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwidGFyZ2V0IiwiZGF0YVdpdGhTdGF0dXMiLCJ0eXBlIiwicGFyc2UiLCJyZXN1bHQiLCJoZWFkZXIiLCJza2lwRW1wdHlMaW5lcyIsImNvbXBsZXRlIiwibWFwIiwicm93Iiwic3RhdHVzIiwic3VtbWFyeSIsImNsYXMiLCJ3b3JrYm9vayIsInJlYWQiLCJzaGVldE5hbWUiLCJTaGVldE5hbWVzIiwid29ya3NoZWV0IiwiU2hlZXRzIiwianNvbkRhdGEiLCJ1dGlscyIsInNoZWV0X3RvX2pzb24iLCJoZWFkZXJzIiwicm93cyIsInNsaWNlIiwicm93RGF0YSIsImZvckVhY2giLCJpbmRleCIsImNvbnNvbGUiLCJlcnJvciIsInJlYWRBc1RleHQiLCJyZWFkQXNCaW5hcnlTdHJpbmciLCJoYW5kbGVGaWxlVXBsb2FkIiwibm9uRHVwbGljYXRlRmlsZXMiLCJmaWx0ZXIiLCJpc0R1cGxpY2F0ZSIsInNvbWUiLCJpdGVtIiwibmFtZSIsInNpemUiLCJ3YXJuIiwibGVuZ3RoIiwiZmlsZXNXaXRoRGF0YSIsImFsbCIsImNsYXNzaWZpY2F0aW9uIiwicHJldkRhdGEiLCJoYW5kbGVGaWxlQ2hhbmdlIiwiZXZlbnQiLCJzZWxlY3RlZEZpbGVzIiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyZWRGaWxlcyIsImluY2x1ZGVzIiwicHJldkZpbGVzIiwiaGFuZGxlRmlsZVNlbGVjdCIsImV4aXN0aW5nRmlsZURhdGEiLCJmaW5kIiwiaGFuZGxlRHJvcCIsInByZXZlbnREZWZhdWx0IiwiZHJvcHBlZEZpbGVzIiwiZGF0YVRyYW5zZmVyIiwiaGFuZGxlUmVtb3ZlRmlsZSIsInByZXZGaWxlIiwicmVtYWluaW5nRmlsZXMiLCJjdXJyZW50IiwidmFsdWUiLCJzdGFydFN0cmVhbWluZyIsImZpbGVEYXRhIiwiaSIsInVwZGF0ZVJvd1N0YXR1cyIsInN0cmVhbVN1bW1hcnkiLCJ1cGRhdGVSb3dTdW1tYXJ5IiwiciIsImlkeCIsInJvd0luZGV4IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJFcnJvciIsImdldFJlYWRlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImRvbmUiLCJjaHVuayIsImRlY29kZSIsInN0cmVhbSIsInN1bW1hcnlDaHVuayIsInJlcGxhY2UiLCJ0cmltIiwiY2xhc3NpZmljYXRpb25DaHVuayIsInVwZGF0ZVJvd0NsYXNzaWZpY2F0aW9uIiwicHJldiIsInVwZGF0ZVN1bW1hcnlJbkdsb2JhbFN0YXRlIiwibmV3U3VtbWFyeSIsIlByb3ZpZGVyIiwidXNlTWFpblByb3ZpZGVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/Globalcontext.jsx\n"));

/***/ })

});