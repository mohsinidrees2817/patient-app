"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"2fe909a9f85b\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvbW9oc2luaWRyZWVzL0Rlc2t0b3AvcGF0aWVudC1hcHAvc3RhdGljL3NyYy9hcHAvZ2xvYmFscy5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIyZmU5MDlhOWY4NWJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/context/Globalcontext.jsx":
/*!***************************************!*\
  !*** ./src/context/Globalcontext.jsx ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MainProvider: () => (/* binding */ MainProvider),\n/* harmony export */   useMainProvider: () => (/* binding */ useMainProvider)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! papaparse */ \"(app-pages-browser)/./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\");\n/* __next_internal_client_entry_do_not_use__ MainProvider,useMainProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst MainContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nconst MainProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [tableData, setTableData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [proccesingState, setProccesingState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [files, setFiles] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const API_BASE = \"http://localhost:8000\" || 0;\n    const allowedFileTypes = [\n        \"text/csv\",\n        \"application/vnd.ms-excel\",\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n    ];\n    const parseFile = (file)=>{\n        return new Promise((resolve)=>{\n            const reader = new FileReader();\n            reader.onload = (param)=>{\n                let { target } = param;\n                let dataWithStatus = [];\n                if (file.type === \"text/csv\") {\n                    papaparse__WEBPACK_IMPORTED_MODULE_2___default().parse(target.result, {\n                        header: true,\n                        skipEmptyLines: true,\n                        complete: (result)=>{\n                            dataWithStatus = result.data.map((row)=>({\n                                    ...row,\n                                    status: \"Pending\",\n                                    summary: \"\"\n                                }));\n                            resolve(dataWithStatus);\n                        }\n                    });\n                } else if (file.type === \"application/vnd.ms-excel\" || file.type === \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") {\n                    const workbook = xlsx__WEBPACK_IMPORTED_MODULE_3__.read(target.result, {\n                        type: \"binary\"\n                    });\n                    const sheetName = workbook.SheetNames[0];\n                    const worksheet = workbook.Sheets[sheetName];\n                    const jsonData = xlsx__WEBPACK_IMPORTED_MODULE_3__.utils.sheet_to_json(worksheet, {\n                        header: 1\n                    });\n                    const headers = jsonData[0];\n                    const rows = jsonData.slice(1);\n                    dataWithStatus = rows.map((row)=>{\n                        const rowData = {};\n                        headers.forEach((header, index)=>{\n                            rowData[header] = row[index];\n                        });\n                        return {\n                            ...rowData,\n                            status: \"Pending\",\n                            summary: \"\"\n                        };\n                    });\n                    resolve(dataWithStatus);\n                } else {\n                    console.error(\"Unsupported file type:\", file.type);\n                    resolve([]);\n                }\n            };\n            if (file.type === \"text/csv\") {\n                reader.readAsText(file);\n            } else {\n                reader.readAsBinaryString(file);\n            }\n        });\n    };\n    const handleFileUpload = async (files)=>{\n        const nonDuplicateFiles = files.filter((file)=>{\n            const isDuplicate = data.some((item)=>item.file.name === file.name && item.file.size === file.size);\n            if (isDuplicate) {\n                console.warn(\"Skipping duplicate file: \".concat(file.name));\n                return false;\n            }\n            return true;\n        });\n        if (nonDuplicateFiles.length === 0) {\n            console.warn(\"No new files to upload (all files are duplicates).\");\n            return;\n        }\n        const filesWithData = await Promise.all(nonDuplicateFiles.map(async (file)=>{\n            const tableData = await parseFile(file);\n            return {\n                file,\n                status: \"Pending\",\n                summary: \"\",\n                tableData\n            };\n        }));\n        setData((prevData)=>[\n                ...prevData,\n                ...filesWithData\n            ]);\n        setSelectedFile(nonDuplicateFiles[0]);\n        setTableData(filesWithData[0].tableData);\n    };\n    const handleFileChange = (event)=>{\n        const selectedFiles = Array.from(event.target.files);\n        const filteredFiles = selectedFiles.filter((file)=>allowedFileTypes.includes(file.type));\n        if (filteredFiles.length > 0) {\n            setFiles((prevFiles)=>[\n                    ...prevFiles,\n                    ...filteredFiles\n                ]);\n            handleFileUpload(filteredFiles);\n        }\n    };\n    const handleFileSelect = (file)=>{\n        setSelectedFile(file);\n        const existingFileData = data.find((item)=>item.file.name === file.name);\n        if (existingFileData) {\n            setTableData(existingFileData.tableData);\n        }\n    };\n    const handleDrop = (event)=>{\n        event.preventDefault();\n        const droppedFiles = Array.from(event.dataTransfer.files);\n        const filteredFiles = droppedFiles.filter((file)=>allowedFileTypes.includes(file.type));\n        if (filteredFiles.length > 0) {\n            setFiles((prevFiles)=>[\n                    ...prevFiles,\n                    ...filteredFiles\n                ]);\n            setData((prevData)=>[\n                    ...prevData,\n                    ...filteredFiles\n                ]);\n        }\n    };\n    const handleRemoveFile = (file)=>{\n        setData((prevData)=>prevData.filter((item)=>item.file.name !== file.name));\n        setFiles((prevFiles)=>prevFiles.filter((prevFile)=>prevFile.name !== file.name));\n        if ((selectedFile === null || selectedFile === void 0 ? void 0 : selectedFile.name) === file.name) {\n            const remainingFiles = data.filter((item)=>item.file.name !== file.name);\n            if (remainingFiles.length > 0) {\n                setSelectedFile(remainingFiles[0].file);\n                setTableData(remainingFiles[0].tableData);\n            } else {\n                setSelectedFile(null);\n                setTableData([]);\n            }\n        }\n    };\n    const startStreaming = async (file)=>{\n        const fileData = data.find((item)=>item.file.name === file.name);\n        if (!fileData || fileData.status !== \"Pending\") return;\n        setProccesingState(true);\n        setData((prevData)=>prevData.map((item)=>item.file.name === file.name ? {\n                    ...item,\n                    status: \"In Progress\"\n                } : item));\n        for(let i = 0; i < fileData.tableData.length; i++){\n            const row = fileData.tableData[i];\n            if (row.status === \"Done\") {\n                continue;\n            }\n            updateRowStatus(i, \"In Progress\");\n            const summary = await streamSummary(row, i, file);\n            if (summary) {\n                updateRowStatus(i, \"Done\");\n                updateRowSummary(i, summary);\n                setData((prevData)=>prevData.map((item)=>item.file.name === file.name ? {\n                            ...item,\n                            tableData: item.tableData.map((r, idx)=>idx === i ? {\n                                    ...r,\n                                    status: \"Done\",\n                                    summary\n                                } : r)\n                        } : item));\n            }\n        }\n        setData((prevData)=>prevData.map((item)=>item.file.name === file.name ? {\n                    ...item,\n                    status: \"Done\"\n                } : item));\n        setProccesingState(false);\n    };\n    const streamSummary = async (row, rowIndex, file)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE, \"/generate-summary\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(row)\n            });\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const reader = response.body.getReader();\n            const decoder = new TextDecoder();\n            let summary = \"\";\n            let classification = \"\";\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                const chunk = decoder.decode(value, {\n                    stream: true\n                });\n                if (chunk.includes(\"summary:\")) {\n                    const summaryChunk = chunk.replace(\"summary:\", \"\").trim();\n                    summary += summaryChunk + \" \";\n                    updateRowSummary(rowIndex, summary);\n                } else if (chunk.includes(\"classification:\")) {\n                    const classificationChunk = chunk.replace(\"classification:\", \"\").trim();\n                    classification += classificationChunk + \" \";\n                    updateRowClassification(rowIndex, classification);\n                }\n            }\n            updateRowStatus(rowIndex, \"Done\");\n        } catch (error) {\n            console.error(\"Error streaming summary:\", error);\n            updateRowStatus(rowIndex, \"Error!\");\n            updateRowSummary(rowIndex, \"\");\n            updateRowClassification(rowIndex, \"\");\n            setData((prevData)=>prevData.map((item)=>item.file.name === file.name ? {\n                        ...item,\n                        tableData: item.tableData.map((r, idx)=>idx === rowIndex ? {\n                                ...r,\n                                status: \"Error!\",\n                                summary: \"\",\n                                classification: \"\"\n                            } : r)\n                    } : item));\n        }\n    };\n    const updateRowClassification = (rowIndex, classification)=>{\n        setTableData((prev)=>prev.map((row, i)=>i === rowIndex ? {\n                    ...row,\n                    classification\n                } : row));\n        setData((prevData)=>prevData.map((item)=>item.file.name === selectedFile.name ? {\n                    ...item,\n                    tableData: item.tableData.map((row, idx)=>idx === rowIndex ? {\n                            ...row,\n                            classification\n                        } : row)\n                } : item));\n    };\n    const updateRowSummary = (rowIndex, summary)=>{\n        setTableData((prev)=>prev.map((row, i)=>i === rowIndex ? {\n                    ...row,\n                    summary\n                } : row));\n        setData((prevData)=>prevData.map((item)=>item.file.name === selectedFile.name ? {\n                    ...item,\n                    tableData: item.tableData.map((row, idx)=>idx === rowIndex ? {\n                            ...row,\n                            summary\n                        } : row)\n                } : item));\n    };\n    const updateRowStatus = (index, status)=>{\n        setTableData((prev)=>prev.map((row, i)=>i === index ? {\n                    ...row,\n                    status\n                } : row));\n        setData((prevData)=>prevData.map((item)=>item.file.name === selectedFile.name ? {\n                    ...item,\n                    tableData: item.tableData.map((row, idx)=>idx === index ? {\n                            ...row,\n                            status\n                        } : row)\n                } : item));\n    };\n    const updateSummaryInGlobalState = (file, rowIndex, newSummary)=>{\n        setData((prevData)=>prevData.map((item)=>item.file.name === file.name ? {\n                    ...item,\n                    status: \"Pending\",\n                    tableData: item.tableData.map((row, idx)=>idx === rowIndex ? {\n                            ...row,\n                            summary: newSummary,\n                            status: \"Pending\"\n                        } : row)\n                } : item));\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MainContext.Provider, {\n        value: {\n            data,\n            setData,\n            selectedFile,\n            setSelectedFile,\n            tableData,\n            setTableData,\n            handleFileUpload,\n            startStreaming,\n            updateRowSummary,\n            updateRowStatus,\n            updateSummaryInGlobalState,\n            proccesingState,\n            setProccesingState,\n            files,\n            setFiles,\n            handleFileChange,\n            handleFileSelect,\n            handleDrop,\n            handleRemoveFile\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/mohsinidrees/Desktop/patient-app/static/src/context/Globalcontext.jsx\",\n        lineNumber: 371,\n        columnNumber: 5\n    }, undefined);\n};\n_s(MainProvider, \"ZuR22oAp/F9EYXm+6joOyMZ4/g8=\");\n_c = MainProvider;\nconst useMainProvider = ()=>{\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MainContext);\n};\n_s1(useMainProvider, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"MainProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L0dsb2JhbGNvbnRleHQuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFDMkU7QUFDOUM7QUFDQTtBQUU3QixNQUFNTyw0QkFBY04sb0RBQWFBO0FBRTFCLE1BQU1PLGVBQWU7UUFBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQ3ZDLE1BQU0sQ0FBQ0MsTUFBTUMsUUFBUSxHQUFHUiwrQ0FBUUEsQ0FBQyxFQUFFO0lBQ25DLE1BQU0sQ0FBQ1MsY0FBY0MsZ0JBQWdCLEdBQUdWLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ1csV0FBV0MsYUFBYSxHQUFHWiwrQ0FBUUEsQ0FBQyxFQUFFO0lBQzdDLE1BQU0sQ0FBQ2EsaUJBQWlCQyxtQkFBbUIsR0FBR2QsK0NBQVFBLENBQUM7SUFDdkQsTUFBTSxDQUFDZSxPQUFPQyxTQUFTLEdBQUdoQiwrQ0FBUUEsQ0FBQyxFQUFFO0lBQ3JDLE1BQU1pQixlQUFlaEIsNkNBQU1BLENBQUM7SUFHNUIsTUFBTWlCLFdBQVdDLHVCQUFnQyxJQUFJLENBQUU7SUFFdkQsTUFBTUcsbUJBQW1CO1FBQ3ZCO1FBQ0E7UUFDQTtLQUNEO0lBRUQsTUFBTUMsWUFBWSxDQUFDQztRQUNqQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0M7WUFDbEIsTUFBTUMsU0FBUyxJQUFJQztZQUNuQkQsT0FBT0UsTUFBTSxHQUFHO29CQUFDLEVBQUVDLE1BQU0sRUFBRTtnQkFDekIsSUFBSUMsaUJBQWlCLEVBQUU7Z0JBRXZCLElBQUlQLEtBQUtRLElBQUksS0FBSyxZQUFZO29CQUM1QjlCLHNEQUFVLENBQUM0QixPQUFPSSxNQUFNLEVBQUU7d0JBQ3hCQyxRQUFRO3dCQUNSQyxnQkFBZ0I7d0JBQ2hCQyxVQUFVLENBQUNIOzRCQUNUSCxpQkFBaUJHLE9BQU8zQixJQUFJLENBQUMrQixHQUFHLENBQUMsQ0FBQ0MsTUFBUztvQ0FDekMsR0FBR0EsR0FBRztvQ0FDTkMsUUFBUTtvQ0FDUkMsU0FBUztn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SUFHVjtJQUVBLE1BQU0wRCw2QkFBNkIsQ0FBQ3BHLE1BQU00RSxVQUFVeUI7UUFDbERySCxRQUFRLENBQUNpRSxXQUNQQSxTQUFTbkMsR0FBRyxDQUFDLENBQUM0QixPQUNaQSxLQUFLMUMsSUFBSSxDQUFDMkMsSUFBSSxLQUFLM0MsS0FBSzJDLElBQUksR0FDeEI7b0JBQ0UsR0FBR0QsSUFBSTtvQkFDUDFCLFFBQVE7b0JBQ1I3QixXQUFXdUQsS0FBS3ZELFNBQVMsQ0FBQzJCLEdBQUcsQ0FBQyxDQUFDQyxLQUFLNEQsTUFDbENBLFFBQVFDLFdBQ0o7NEJBQUUsR0FBRzdELEdBQUc7NEJBQUVFLFNBQVNvRjs0QkFBWXJGLFFBQVE7d0JBQVUsSUFDakREO2dCQUVSLElBQ0EyQjtJQUdWO0lBRUEscUJBQ0UsOERBQUM5RCxZQUFZMEgsUUFBUTtRQUNuQlosT0FBTztZQUNMM0c7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQWlEO1lBQ0ErQjtZQUNBSztZQUNBRjtZQUNBNkI7WUFDQS9HO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0EwRDtZQUNBUTtZQUNBRztZQUNBSTtRQUNGO2tCQUVDbkY7Ozs7OztBQUdQLEVBQUU7R0FyWVdEO0tBQUFBO0FBc1lOLE1BQU0wSCxrQkFBa0I7O0lBQU1oSSxPQUFBQSxpREFBVUEsQ0FBQ0s7QUFBVyxFQUFFO0lBQWhEMkgiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tb2hzaW5pZHJlZXMvRGVza3RvcC9wYXRpZW50LWFwcC9zdGF0aWMvc3JjL2NvbnRleHQvR2xvYmFsY29udGV4dC5qc3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFBhcGEgZnJvbSBcInBhcGFwYXJzZVwiO1xuaW1wb3J0ICogYXMgWExTWCBmcm9tIFwieGxzeFwiO1xuXG5jb25zdCBNYWluQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKTtcblxuZXhwb3J0IGNvbnN0IE1haW5Qcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbc2VsZWN0ZWRGaWxlLCBzZXRTZWxlY3RlZEZpbGVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFt0YWJsZURhdGEsIHNldFRhYmxlRGF0YV0gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtwcm9jY2VzaW5nU3RhdGUsIHNldFByb2NjZXNpbmdTdGF0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtmaWxlcywgc2V0RmlsZXNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBmaWxlSW5wdXRSZWYgPSB1c2VSZWYobnVsbCk7XG5cblxuICBjb25zdCBBUElfQkFTRSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9CQVNFIHx8IFwiXCI7XG5cbiAgY29uc3QgYWxsb3dlZEZpbGVUeXBlcyA9IFtcbiAgICBcInRleHQvY3N2XCIsXG4gICAgXCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWxcIixcbiAgICBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0XCIsXG4gIF07XG5cbiAgY29uc3QgcGFyc2VGaWxlID0gKGZpbGUpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICByZWFkZXIub25sb2FkID0gKHsgdGFyZ2V0IH0pID0+IHtcbiAgICAgICAgbGV0IGRhdGFXaXRoU3RhdHVzID0gW107XG5cbiAgICAgICAgaWYgKGZpbGUudHlwZSA9PT0gXCJ0ZXh0L2NzdlwiKSB7XG4gICAgICAgICAgUGFwYS5wYXJzZSh0YXJnZXQucmVzdWx0LCB7XG4gICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICBza2lwRW1wdHlMaW5lczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGRhdGFXaXRoU3RhdHVzID0gcmVzdWx0LmRhdGEubWFwKChyb3cpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4ucm93LFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJQZW5kaW5nXCIsXG4gICAgICAgICAgICAgICAgc3VtbWFyeTogXCJcIixcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICByZXNvbHZlKGRhdGFXaXRoU3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgZmlsZS50eXBlID09PSBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbFwiIHx8XG4gICAgICAgICAgZmlsZS50eXBlID09PVxuICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldFwiXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHdvcmtib29rID0gWExTWC5yZWFkKHRhcmdldC5yZXN1bHQsIHsgdHlwZTogXCJiaW5hcnlcIiB9KTtcbiAgICAgICAgICBjb25zdCBzaGVldE5hbWUgPSB3b3JrYm9vay5TaGVldE5hbWVzWzBdO1xuICAgICAgICAgIGNvbnN0IHdvcmtzaGVldCA9IHdvcmtib29rLlNoZWV0c1tzaGVldE5hbWVdO1xuICAgICAgICAgIGNvbnN0IGpzb25EYXRhID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtzaGVldCwgeyBoZWFkZXI6IDEgfSk7XG5cbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0ganNvbkRhdGFbMF07XG4gICAgICAgICAgY29uc3Qgcm93cyA9IGpzb25EYXRhLnNsaWNlKDEpO1xuXG4gICAgICAgICAgZGF0YVdpdGhTdGF0dXMgPSByb3dzLm1hcCgocm93KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3dEYXRhID0ge307XG4gICAgICAgICAgICBoZWFkZXJzLmZvckVhY2goKGhlYWRlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgcm93RGF0YVtoZWFkZXJdID0gcm93W2luZGV4XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ucm93RGF0YSxcbiAgICAgICAgICAgICAgc3RhdHVzOiBcIlBlbmRpbmdcIixcbiAgICAgICAgICAgICAgc3VtbWFyeTogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXNvbHZlKGRhdGFXaXRoU3RhdHVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5zdXBwb3J0ZWQgZmlsZSB0eXBlOlwiLCBmaWxlLnR5cGUpO1xuICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoZmlsZS50eXBlID09PSBcInRleHQvY3N2XCIpIHtcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFkZXIucmVhZEFzQmluYXJ5U3RyaW5nKGZpbGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUZpbGVVcGxvYWQgPSBhc3luYyAoZmlsZXMpID0+IHtcbiAgICBjb25zdCBub25EdXBsaWNhdGVGaWxlcyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgaXNEdXBsaWNhdGUgPSBkYXRhLnNvbWUoXG4gICAgICAgIChpdGVtKSA9PiBpdGVtLmZpbGUubmFtZSA9PT0gZmlsZS5uYW1lICYmIGl0ZW0uZmlsZS5zaXplID09PSBmaWxlLnNpemVcbiAgICAgICk7XG4gICAgICBpZiAoaXNEdXBsaWNhdGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBTa2lwcGluZyBkdXBsaWNhdGUgZmlsZTogJHtmaWxlLm5hbWV9YCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKG5vbkR1cGxpY2F0ZUZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKFwiTm8gbmV3IGZpbGVzIHRvIHVwbG9hZCAoYWxsIGZpbGVzIGFyZSBkdXBsaWNhdGVzKS5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZXNXaXRoRGF0YSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgbm9uRHVwbGljYXRlRmlsZXMubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhYmxlRGF0YSA9IGF3YWl0IHBhcnNlRmlsZShmaWxlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaWxlLFxuICAgICAgICAgIHN0YXR1czogXCJQZW5kaW5nXCIsXG4gICAgICAgICAgc3VtbWFyeTogXCJcIixcbiAgICAgICAgICB0YWJsZURhdGEsXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICk7XG5cbiAgICBzZXREYXRhKChwcmV2RGF0YSkgPT4gWy4uLnByZXZEYXRhLCAuLi5maWxlc1dpdGhEYXRhXSk7XG5cbiAgICBzZXRTZWxlY3RlZEZpbGUobm9uRHVwbGljYXRlRmlsZXNbMF0pO1xuXG4gICAgc2V0VGFibGVEYXRhKGZpbGVzV2l0aERhdGFbMF0udGFibGVEYXRhKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVGaWxlQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWRGaWxlcyA9IEFycmF5LmZyb20oZXZlbnQudGFyZ2V0LmZpbGVzKTtcbiAgICBjb25zdCBmaWx0ZXJlZEZpbGVzID0gc2VsZWN0ZWRGaWxlcy5maWx0ZXIoKGZpbGUpID0+XG4gICAgICBhbGxvd2VkRmlsZVR5cGVzLmluY2x1ZGVzKGZpbGUudHlwZSlcbiAgICApO1xuXG4gICAgaWYgKGZpbHRlcmVkRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgc2V0RmlsZXMoKHByZXZGaWxlcykgPT4gWy4uLnByZXZGaWxlcywgLi4uZmlsdGVyZWRGaWxlc10pO1xuICAgICAgaGFuZGxlRmlsZVVwbG9hZChmaWx0ZXJlZEZpbGVzKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRmlsZVNlbGVjdCA9IChmaWxlKSA9PiB7XG4gICAgc2V0U2VsZWN0ZWRGaWxlKGZpbGUpO1xuXG4gICAgY29uc3QgZXhpc3RpbmdGaWxlRGF0YSA9IGRhdGEuZmluZCgoaXRlbSkgPT4gaXRlbS5maWxlLm5hbWUgPT09IGZpbGUubmFtZSk7XG5cbiAgICBpZiAoZXhpc3RpbmdGaWxlRGF0YSkge1xuICAgICAgc2V0VGFibGVEYXRhKGV4aXN0aW5nRmlsZURhdGEudGFibGVEYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRHJvcCA9IChldmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgZHJvcHBlZEZpbGVzID0gQXJyYXkuZnJvbShldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgIGNvbnN0IGZpbHRlcmVkRmlsZXMgPSBkcm9wcGVkRmlsZXMuZmlsdGVyKChmaWxlKSA9PlxuICAgICAgYWxsb3dlZEZpbGVUeXBlcy5pbmNsdWRlcyhmaWxlLnR5cGUpXG4gICAgKTtcblxuICAgIGlmIChmaWx0ZXJlZEZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNldEZpbGVzKChwcmV2RmlsZXMpID0+IFsuLi5wcmV2RmlsZXMsIC4uLmZpbHRlcmVkRmlsZXNdKTtcbiAgICAgIHNldERhdGEoKHByZXZEYXRhKSA9PiBbLi4ucHJldkRhdGEsIC4uLmZpbHRlcmVkRmlsZXNdKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmVtb3ZlRmlsZSA9IChmaWxlKSA9PiB7XG4gICAgc2V0RGF0YSgocHJldkRhdGEpID0+XG4gICAgICBwcmV2RGF0YS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uZmlsZS5uYW1lICE9PSBmaWxlLm5hbWUpXG4gICAgKTtcblxuICAgIHNldEZpbGVzKChwcmV2RmlsZXMpID0+XG4gICAgICBwcmV2RmlsZXMuZmlsdGVyKChwcmV2RmlsZSkgPT4gcHJldkZpbGUubmFtZSAhPT0gZmlsZS5uYW1lKVxuICAgICk7XG5cbiAgICBpZiAoc2VsZWN0ZWRGaWxlPy5uYW1lID09PSBmaWxlLm5hbWUpIHtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0ZpbGVzID0gZGF0YS5maWx0ZXIoXG4gICAgICAgIChpdGVtKSA9PiBpdGVtLmZpbGUubmFtZSAhPT0gZmlsZS5uYW1lXG4gICAgICApO1xuXG4gICAgICBpZiAocmVtYWluaW5nRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZXRTZWxlY3RlZEZpbGUocmVtYWluaW5nRmlsZXNbMF0uZmlsZSk7XG4gICAgICAgIHNldFRhYmxlRGF0YShyZW1haW5pbmdGaWxlc1swXS50YWJsZURhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWRGaWxlKG51bGwpO1xuICAgICAgICBzZXRUYWJsZURhdGEoW10pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBzdGFydFN0cmVhbWluZyA9IGFzeW5jIChmaWxlKSA9PiB7XG4gICAgY29uc3QgZmlsZURhdGEgPSBkYXRhLmZpbmQoKGl0ZW0pID0+IGl0ZW0uZmlsZS5uYW1lID09PSBmaWxlLm5hbWUpO1xuICAgIGlmICghZmlsZURhdGEgfHwgZmlsZURhdGEuc3RhdHVzICE9PSBcIlBlbmRpbmdcIikgcmV0dXJuO1xuICAgIHNldFByb2NjZXNpbmdTdGF0ZSh0cnVlKTtcblxuICAgIHNldERhdGEoKHByZXZEYXRhKSA9PlxuICAgICAgcHJldkRhdGEubWFwKChpdGVtKSA9PlxuICAgICAgICBpdGVtLmZpbGUubmFtZSA9PT0gZmlsZS5uYW1lID8geyAuLi5pdGVtLCBzdGF0dXM6IFwiSW4gUHJvZ3Jlc3NcIiB9IDogaXRlbVxuICAgICAgKVxuICAgICk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVEYXRhLnRhYmxlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgcm93ID0gZmlsZURhdGEudGFibGVEYXRhW2ldO1xuXG4gICAgICBpZiAocm93LnN0YXR1cyA9PT0gXCJEb25lXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZVJvd1N0YXR1cyhpLCBcIkluIFByb2dyZXNzXCIpO1xuXG4gICAgICBjb25zdCBzdW1tYXJ5ID0gYXdhaXQgc3RyZWFtU3VtbWFyeShyb3csIGksIGZpbGUpO1xuXG4gICAgICBpZiAoc3VtbWFyeSkge1xuICAgICAgICB1cGRhdGVSb3dTdGF0dXMoaSwgXCJEb25lXCIpO1xuICAgICAgICB1cGRhdGVSb3dTdW1tYXJ5KGksIHN1bW1hcnkpO1xuXG4gICAgICAgIHNldERhdGEoKHByZXZEYXRhKSA9PlxuICAgICAgICAgIHByZXZEYXRhLm1hcCgoaXRlbSkgPT5cbiAgICAgICAgICAgIGl0ZW0uZmlsZS5uYW1lID09PSBmaWxlLm5hbWVcbiAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgICAgdGFibGVEYXRhOiBpdGVtLnRhYmxlRGF0YS5tYXAoKHIsIGlkeCkgPT5cbiAgICAgICAgICAgICAgICAgICAgaWR4ID09PSBpID8geyAuLi5yLCBzdGF0dXM6IFwiRG9uZVwiLCBzdW1tYXJ5IH0gOiByXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiBpdGVtXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldERhdGEoKHByZXZEYXRhKSA9PlxuICAgICAgcHJldkRhdGEubWFwKChpdGVtKSA9PlxuICAgICAgICBpdGVtLmZpbGUubmFtZSA9PT0gZmlsZS5uYW1lID8geyAuLi5pdGVtLCBzdGF0dXM6IFwiRG9uZVwiIH0gOiBpdGVtXG4gICAgICApXG4gICAgKTtcblxuICAgIHNldFByb2NjZXNpbmdTdGF0ZShmYWxzZSk7XG4gIH07XG5cbiAgY29uc3Qgc3RyZWFtU3VtbWFyeSA9IGFzeW5jIChyb3csIHJvd0luZGV4LCBmaWxlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0V9L2dlbmVyYXRlLXN1bW1hcnlgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocm93KSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgIGxldCBzdW1tYXJ5ID0gXCJcIjtcbiAgICAgIGxldCBjbGFzc2lmaWNhdGlvbiA9IFwiXCI7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcblxuICAgICAgICBjb25zdCBjaHVuayA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcblxuICAgICAgICBpZiAoY2h1bmsuaW5jbHVkZXMoXCJzdW1tYXJ5OlwiKSkge1xuICAgICAgICAgIGNvbnN0IHN1bW1hcnlDaHVuayA9IGNodW5rLnJlcGxhY2UoXCJzdW1tYXJ5OlwiLCBcIlwiKS50cmltKCk7XG4gICAgICAgICAgc3VtbWFyeSArPSBzdW1tYXJ5Q2h1bmsgKyBcIiBcIjtcbiAgICAgICAgICB1cGRhdGVSb3dTdW1tYXJ5KHJvd0luZGV4LCBzdW1tYXJ5KTtcbiAgICAgICAgfSBlbHNlIGlmIChjaHVuay5pbmNsdWRlcyhcImNsYXNzaWZpY2F0aW9uOlwiKSkge1xuICAgICAgICAgIGNvbnN0IGNsYXNzaWZpY2F0aW9uQ2h1bmsgPSBjaHVua1xuICAgICAgICAgICAgLnJlcGxhY2UoXCJjbGFzc2lmaWNhdGlvbjpcIiwgXCJcIilcbiAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgICAgY2xhc3NpZmljYXRpb24gKz0gY2xhc3NpZmljYXRpb25DaHVuayArIFwiIFwiO1xuICAgICAgICAgIHVwZGF0ZVJvd0NsYXNzaWZpY2F0aW9uKHJvd0luZGV4LCBjbGFzc2lmaWNhdGlvbik7IFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZVJvd1N0YXR1cyhyb3dJbmRleCwgXCJEb25lXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc3RyZWFtaW5nIHN1bW1hcnk6XCIsIGVycm9yKTtcbiAgICAgIHVwZGF0ZVJvd1N0YXR1cyhyb3dJbmRleCwgXCJFcnJvciFcIik7XG4gICAgICB1cGRhdGVSb3dTdW1tYXJ5KHJvd0luZGV4LCBcIlwiKTtcbiAgICAgIHVwZGF0ZVJvd0NsYXNzaWZpY2F0aW9uKHJvd0luZGV4LCBcIlwiKTtcblxuICAgICAgc2V0RGF0YSgocHJldkRhdGEpID0+XG4gICAgICAgIHByZXZEYXRhLm1hcCgoaXRlbSkgPT5cbiAgICAgICAgICBpdGVtLmZpbGUubmFtZSA9PT0gZmlsZS5uYW1lXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgIHRhYmxlRGF0YTogaXRlbS50YWJsZURhdGEubWFwKChyLCBpZHgpID0+XG4gICAgICAgICAgICAgICAgICBpZHggPT09IHJvd0luZGV4XG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJFcnJvciFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2lmaWNhdGlvbjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogclxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogaXRlbVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB1cGRhdGVSb3dDbGFzc2lmaWNhdGlvbiA9IChyb3dJbmRleCwgY2xhc3NpZmljYXRpb24pID0+IHtcbiAgICBcbiAgICBzZXRUYWJsZURhdGEoKHByZXYpID0+XG4gICAgICBwcmV2Lm1hcCgocm93LCBpKSA9PiAoaSA9PT0gcm93SW5kZXggPyB7IC4uLnJvdywgY2xhc3NpZmljYXRpb24gfSA6IHJvdykpXG4gICAgKTtcblxuICAgIHNldERhdGEoKHByZXZEYXRhKSA9PlxuICAgICAgcHJldkRhdGEubWFwKChpdGVtKSA9PlxuICAgICAgICBpdGVtLmZpbGUubmFtZSA9PT0gc2VsZWN0ZWRGaWxlLm5hbWVcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgICAgdGFibGVEYXRhOiBpdGVtLnRhYmxlRGF0YS5tYXAoKHJvdywgaWR4KSA9PlxuICAgICAgICAgICAgICAgIGlkeCA9PT0gcm93SW5kZXggPyB7IC4uLnJvdywgY2xhc3NpZmljYXRpb24gfSA6IHJvd1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogaXRlbVxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlUm93U3VtbWFyeSA9IChyb3dJbmRleCwgc3VtbWFyeSkgPT4ge1xuICAgIHNldFRhYmxlRGF0YSgocHJldikgPT5cbiAgICAgIHByZXYubWFwKChyb3csIGkpID0+IChpID09PSByb3dJbmRleCA/IHsgLi4ucm93LCBzdW1tYXJ5IH0gOiByb3cpKVxuICAgICk7XG5cbiAgICBzZXREYXRhKChwcmV2RGF0YSkgPT5cbiAgICAgIHByZXZEYXRhLm1hcCgoaXRlbSkgPT5cbiAgICAgICAgaXRlbS5maWxlLm5hbWUgPT09IHNlbGVjdGVkRmlsZS5uYW1lXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgIHRhYmxlRGF0YTogaXRlbS50YWJsZURhdGEubWFwKChyb3csIGlkeCkgPT5cbiAgICAgICAgICAgICAgICBpZHggPT09IHJvd0luZGV4ID8geyAuLi5yb3csIHN1bW1hcnkgfSA6IHJvd1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogaXRlbVxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlUm93U3RhdHVzID0gKGluZGV4LCBzdGF0dXMpID0+IHtcbiAgICBzZXRUYWJsZURhdGEoKHByZXYpID0+XG4gICAgICBwcmV2Lm1hcCgocm93LCBpKSA9PiAoaSA9PT0gaW5kZXggPyB7IC4uLnJvdywgc3RhdHVzIH0gOiByb3cpKVxuICAgICk7XG5cbiAgICBzZXREYXRhKChwcmV2RGF0YSkgPT5cbiAgICAgIHByZXZEYXRhLm1hcCgoaXRlbSkgPT5cbiAgICAgICAgaXRlbS5maWxlLm5hbWUgPT09IHNlbGVjdGVkRmlsZS5uYW1lXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgIHRhYmxlRGF0YTogaXRlbS50YWJsZURhdGEubWFwKChyb3csIGlkeCkgPT5cbiAgICAgICAgICAgICAgICBpZHggPT09IGluZGV4ID8geyAuLi5yb3csIHN0YXR1cyB9IDogcm93XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBpdGVtXG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICBjb25zdCB1cGRhdGVTdW1tYXJ5SW5HbG9iYWxTdGF0ZSA9IChmaWxlLCByb3dJbmRleCwgbmV3U3VtbWFyeSkgPT4ge1xuICAgIHNldERhdGEoKHByZXZEYXRhKSA9PlxuICAgICAgcHJldkRhdGEubWFwKChpdGVtKSA9PlxuICAgICAgICBpdGVtLmZpbGUubmFtZSA9PT0gZmlsZS5uYW1lXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgIHN0YXR1czogXCJQZW5kaW5nXCIsXG4gICAgICAgICAgICAgIHRhYmxlRGF0YTogaXRlbS50YWJsZURhdGEubWFwKChyb3csIGlkeCkgPT5cbiAgICAgICAgICAgICAgICBpZHggPT09IHJvd0luZGV4XG4gICAgICAgICAgICAgICAgICA/IHsgLi4ucm93LCBzdW1tYXJ5OiBuZXdTdW1tYXJ5LCBzdGF0dXM6IFwiUGVuZGluZ1wiIH1cbiAgICAgICAgICAgICAgICAgIDogcm93XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBpdGVtXG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxNYWluQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2V0RGF0YSxcbiAgICAgICAgc2VsZWN0ZWRGaWxlLFxuICAgICAgICBzZXRTZWxlY3RlZEZpbGUsXG4gICAgICAgIHRhYmxlRGF0YSxcbiAgICAgICAgc2V0VGFibGVEYXRhLFxuICAgICAgICBoYW5kbGVGaWxlVXBsb2FkLFxuICAgICAgICBzdGFydFN0cmVhbWluZyxcbiAgICAgICAgdXBkYXRlUm93U3VtbWFyeSxcbiAgICAgICAgdXBkYXRlUm93U3RhdHVzLFxuICAgICAgICB1cGRhdGVTdW1tYXJ5SW5HbG9iYWxTdGF0ZSxcbiAgICAgICAgcHJvY2Nlc2luZ1N0YXRlLFxuICAgICAgICBzZXRQcm9jY2VzaW5nU3RhdGUsXG4gICAgICAgIGZpbGVzLFxuICAgICAgICBzZXRGaWxlcyxcbiAgICAgICAgaGFuZGxlRmlsZUNoYW5nZSxcbiAgICAgICAgaGFuZGxlRmlsZVNlbGVjdCxcbiAgICAgICAgaGFuZGxlRHJvcCxcbiAgICAgICAgaGFuZGxlUmVtb3ZlRmlsZSxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvTWFpbkNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuZXhwb3J0IGNvbnN0IHVzZU1haW5Qcm92aWRlciA9ICgpID0+IHVzZUNvbnRleHQoTWFpbkNvbnRleHQpO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZVJlZiIsIlBhcGEiLCJYTFNYIiwiTWFpbkNvbnRleHQiLCJNYWluUHJvdmlkZXIiLCJjaGlsZHJlbiIsImRhdGEiLCJzZXREYXRhIiwic2VsZWN0ZWRGaWxlIiwic2V0U2VsZWN0ZWRGaWxlIiwidGFibGVEYXRhIiwic2V0VGFibGVEYXRhIiwicHJvY2Nlc2luZ1N0YXRlIiwic2V0UHJvY2Nlc2luZ1N0YXRlIiwiZmlsZXMiLCJzZXRGaWxlcyIsImZpbGVJbnB1dFJlZiIsIkFQSV9CQVNFIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9CQVNFIiwiYWxsb3dlZEZpbGVUeXBlcyIsInBhcnNlRmlsZSIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJ0YXJnZXQiLCJkYXRhV2l0aFN0YXR1cyIsInR5cGUiLCJwYXJzZSIsInJlc3VsdCIsImhlYWRlciIsInNraXBFbXB0eUxpbmVzIiwiY29tcGxldGUiLCJtYXAiLCJyb3ciLCJzdGF0dXMiLCJzdW1tYXJ5Iiwid29ya2Jvb2siLCJyZWFkIiwic2hlZXROYW1lIiwiU2hlZXROYW1lcyIsIndvcmtzaGVldCIsIlNoZWV0cyIsImpzb25EYXRhIiwidXRpbHMiLCJzaGVldF90b19qc29uIiwiaGVhZGVycyIsInJvd3MiLCJzbGljZSIsInJvd0RhdGEiLCJmb3JFYWNoIiwiaW5kZXgiLCJjb25zb2xlIiwiZXJyb3IiLCJyZWFkQXNUZXh0IiwicmVhZEFzQmluYXJ5U3RyaW5nIiwiaGFuZGxlRmlsZVVwbG9hZCIsIm5vbkR1cGxpY2F0ZUZpbGVzIiwiZmlsdGVyIiwiaXNEdXBsaWNhdGUiLCJzb21lIiwiaXRlbSIsIm5hbWUiLCJzaXplIiwid2FybiIsImxlbmd0aCIsImZpbGVzV2l0aERhdGEiLCJhbGwiLCJwcmV2RGF0YSIsImhhbmRsZUZpbGVDaGFuZ2UiLCJldmVudCIsInNlbGVjdGVkRmlsZXMiLCJBcnJheSIsImZyb20iLCJmaWx0ZXJlZEZpbGVzIiwiaW5jbHVkZXMiLCJwcmV2RmlsZXMiLCJoYW5kbGVGaWxlU2VsZWN0IiwiZXhpc3RpbmdGaWxlRGF0YSIsImZpbmQiLCJoYW5kbGVEcm9wIiwicHJldmVudERlZmF1bHQiLCJkcm9wcGVkRmlsZXMiLCJkYXRhVHJhbnNmZXIiLCJoYW5kbGVSZW1vdmVGaWxlIiwicHJldkZpbGUiLCJyZW1haW5pbmdGaWxlcyIsInN0YXJ0U3RyZWFtaW5nIiwiZmlsZURhdGEiLCJpIiwidXBkYXRlUm93U3RhdHVzIiwic3RyZWFtU3VtbWFyeSIsInVwZGF0ZVJvd1N1bW1hcnkiLCJyIiwiaWR4Iiwicm93SW5kZXgiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsIkVycm9yIiwiZ2V0UmVhZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiY2xhc3NpZmljYXRpb24iLCJkb25lIiwidmFsdWUiLCJjaHVuayIsImRlY29kZSIsInN0cmVhbSIsInN1bW1hcnlDaHVuayIsInJlcGxhY2UiLCJ0cmltIiwiY2xhc3NpZmljYXRpb25DaHVuayIsInVwZGF0ZVJvd0NsYXNzaWZpY2F0aW9uIiwicHJldiIsInVwZGF0ZVN1bW1hcnlJbkdsb2JhbFN0YXRlIiwibmV3U3VtbWFyeSIsIlByb3ZpZGVyIiwidXNlTWFpblByb3ZpZGVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/Globalcontext.jsx\n"));

/***/ })

});